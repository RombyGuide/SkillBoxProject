/**
 * Author Roman Blinov
 */

/*
Тестовое задание от ООО Бизнес Технологии
Псевдокод
Данный псевдокод используется для описания алгоритмов.

1. Отступ от левого поля указывает на уровень вложенности.
2. Циклы while, for, repeat и условные конструкции имеют тот же смысл, что и в pascal-е.
3. Символ “--” обозначает комментарий
4. Символ “:=” обозначает присваивание
5. Переменные локальны в рамках процедуры, если не оговорено иначе
6. Индекс массива пишется в квадратных скобках, конструкция A[i] означает i элемент в массиве A
7. Возможно использование объектов, состоящих из нескольких полей, или имеющих несколько атрибутов, значения поля записывается как ИмяПоля[ИмяОбъекта].
К примеру, длина массива A записывается как Length[A]; что означают квадратные скобки - выясняется по контексту (переменная, обозначающая массив, или объект является указателем на составляющие его данные). После присвоения y:=x для любого поля f будет выполняться равенство f[y]=f[x]; определение того, что является атрибутом – функция, переменная или что-либо еще, - делается по контексту.
8. Указатель может иметь специальное значение NIL, не указывающее ни на какой объект.
9. Параметры передаются по значению: вызванная процедура получает собственную копию параметров, изменения параметров внутри процедуры снаружи не видно. При передаче объектов копируется указатель на данные, соответствующие этому объекту.



Задача

Функция сортирующая массив элементов A:
Sort(A,p,r)
1 if p < r
2    then q := round_half_down((p+r)/2)
3                       Sort(A,p,q)
4                       Sort(A,q+1,r)
5                       Merge(A,p,q,r)

Пример массива:
A = (5,2,4,6,1,3,2,6)

Примера запуска:
Sort(A,1,length[A])


Необходимо:
Разработать алгоритм функции Merge(A,p,q,r) на любом удобном вам языке, с использованием дополнительной памяти или без нее, как вам будет быстрее или удобнее в реализации.
Если у вас получится - с радостью ждем вас для прохождения дополнительного тестирования.
*/

public class TaskMerge {
    public static void main(String[] args) {
        int[] array = {13, 3, 8, 1, 15, 2, 3, 7, 4};
        System.out.print("Массив до сортировки: ");
        for (int i = 0; i < array.length; i++)
            System.out.print(array[i] + " ");
        System.out.println("");
        array = sort(array);
        System.out.print("Массив после сортировки: ");
        for (int i = 0; i < array.length; i++)
            System.out.print(array[i] + " ");
    }

    public static int[] sort(int x[]) {
        //Рекурсия идет до тех пор, пока массив делится
        if (x.length == 1)
            return x;
        else {
            //Разбиваем массив на 2 части
            int half = (int) Math.floor(x.length / 2);
            //1 часть, пустой массив
            int halfFirst[] = new int[half];
            //2 часть, пустой массив
            int halfSecond[] = new int[x.length - half];
            //Заполняем ново созданные массивы значениями
            for (int i = 0; i < x.length; i++) {
                if (i < half)
                    halfFirst[i] = x[i];
                else
                    halfSecond[i - half] = x[i];
            }
            //Рекурсия
            halfFirst = sort(halfFirst);
            //Рекурсия
            halfSecond = sort(halfSecond);
            //Отправляем заполненные значениями массивы в следующий метод
            x = sortNext(halfFirst, halfSecond);
            return x;
        }
    }

    public static int[] sortNext(int x[], int y[]) {
        //Создаем результирующий массив из суммы длин массивов из аргументов метода
        int c[] = new int[x.length + y.length];
        int a = 0, b = 0;
        //Сравниваем массивы, меняем местами элементы, заполняем ново созданный массив
        for (int i = 0; i < x.length + y.length; i++) {
            if (a == x.length) {
                c[i] = y[b];
                b++;
            } else if (b == y.length) {
                c[i] = x[a];
                a++;
            } else if (x[a] > y[b]) {
                c[i] = y[b];
                b++;
            } else {
                c[i] = x[a];
                a++;
            }
        }
        return c;
    }
}
